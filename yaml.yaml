# yaml.yaml is a monad programming language entirely based around YAML files

# https://en.wikipedia.org/wiki/Lambda_calculus
# (λterm.(variable application abstraction))
term:
- variable
- application
- abstraction

# and based on https://yaml.org/spec/1.2/spec.html#id2763452
# we define a mapping between YAML and lambda calculus
# (λnode.((λscalar.variable) (λscalar.application) (λscalar.abstraction))
node:
  scalar: variable
    # left-associative (s0 s1 ...)
  sequence: application
    # commutative (λkey.value) set
  mapping: abstraction

# def identity = λx.x
# TODO consider `~: ~`, `~`
{ x: }:
- x

# def true = λfirst.λsecond.first
{ first: , second: }:
- first
# def false = λfirst.λsecond.second
{ first: , second: }:
- second

# https://en.wikipedia.org/wiki/Church_encoding
# def 0 = λf.λx.x
{ f: , x: }:
- x
# def succ = λn.λf.λx.(f (n f x))
{ n: , f: , x: }:
- f
- - n
  - f
  - x
# def add = λm.λn.λf.λx.(m f (n f x))
{ m: , n: , f: , x: }:
- m
- f
- - n
  - f
  - x

# TODO review and propose better syntax
# def add = λm.λn.(m succ n)
{ m: , n: }:
- { succ: , m: , n: }:
  - m
  - succ
  - n
- { n: , f: , x: }

# https://medium.com/@marinalimeira/understanding-conditional-expressions-with-%CE%BB-calculus-e25393fef86c
# def cond = λx.λy.λc.(c x y)
{ x: , y: , c: }:
- c
- x
- y
# def and = λx.λy.(x y false)
{ x: , y: }:
- x
- y
- false

# https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed-point_combinators_in_lambda_calculus
# def Y = λf.((λx.(f (x x))) (λx.(f (x x))))
{ f: }:
- { x: }:
  - f
  - - x
    - x
- { x: }:
  - f
  - - x
    - x
