# the yaml.yaml interpreter written in yaml.yaml
# this tries to be a comparison to how lisp dialects interpreters are written

# we demonstrate that certain YAML structures
node:
  scalar:
  sequence:
  mapping:
    ? key:
    : value:
# https://yaml.org/spec/1.2/spec.html#id2763452

# can be mapped to lambda calculus terms
term:
  variable:
  abstraction:
  application:
# https://en.wikipedia.org/wiki/Lambda_calculus
# http://www.cs.tau.ac.il/~msagiv/courses/apl12/etc.pdf

# this homomorphism to lambda calculus proves that
# yaml.yaml is a turing complete language
# case scalar: variable
# case sequence: left-associative application
# case mapping:
#  case all keys are scalars: TODO
#  case single kvp:
#   case ~ key: ???
#   case scalar key:
#    case ~ value: TODO
#    case scalar value: TODO
#    case scalar value: TODO
#    case scalar value: TODO
#   case sequence key: ???
#   case mapping key: TODO
# http://dev.stephendiehl.com/fun/003_lambda_calculus.html#let
# left-associative (v0 v1 ...)
# TODO ~ is the fixed point combinator??
# ((λk0.λk1...(~)) v0 v1 ...)

# and, given that you like what you read,
# very terse as a general-purpose language

# the files structure is not yet formalized,
# but it can be thought of as a mapping between
# a key in this file and the name in {name}.yaml.yaml

# the integration with an environment (an OS? a git repository?)
# should be considered thoroughly
# an assumption was necessary for the sake of organization
# https://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html

# def Y = λf.((λx.(f (x x))) (λx.(f (x x))))
# TODO disambiguate YAML falsy values (e.g Y vs true)
Y:
  ? { f: }
  : - ? { x: }
      : - f
        -   - x
            - x
    - ? { x: }
      : - f
        -   - x
            - x
# https://en.wikipedia.org/wiki/Fixed-point_combinator#Fixed-point_combinators_in_lambda_calculus
