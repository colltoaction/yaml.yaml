# the yaml.yaml interpreter written in yaml.yaml
# this tries to be a comparison to how lisp dialects interpreters are written

# we demonstrate that certain YAML structures
node:
  # the ~ scalar might be important enough to warrant its own abstraction
  scalar:
  sequence:
    list:
      head:
        index:
        value:
  mapping:
    list:
      head:
        key:
        value:
# https://yaml.org/spec/1.2/spec.html#id2763452

# can be mapped to lambda calculus terms
term:
  variable:
  abstraction:
    x: variable
    term:
  application:
# https://en.wikipedia.org/wiki/Lambda_calculus
# http://www.cs.tau.ac.il/~msagiv/courses/apl12/etc.pdf

# this homomorphism to lambda calculus proves that
# yaml.yaml is a turing complete language
# TODO ~ is the fixed point combinator itself?
~:
  - Y
  - ? f:
    : scalar: variable
      sequence:
        f:
          mapping:
            - sequence
            - index: key
            # plus ~ to itself?
      # http://dev.stephendiehl.com/fun/003_lambda_calculus.html#let
      # ((λk0.λk1...(~)) v0 v1 ...)
      mapping:
        - ? key:
            value:
          : abstraction:
              x:
                key:
                - scalar: variable
                  sequence: TODO
                  mapping:
                    - key:
                      value:
                # TODO case key ~
                - f: key
              term:
                # TODO case value ~
                - f: value

# and, given that you like what you read,
# very terse as a general-purpose functional programming language

# the files structure is not yet formalized,
# but it can be thought of as a mapping between
# a key in this file and the name in {name}.yaml.yaml

# the integration with an environment (an OS? a git repository?)
# should be considered thoroughly
# an assumption was necessary for the sake of organization
# https://www.cs.virginia.edu/~evans/cs655/readings/smalltalk.html
